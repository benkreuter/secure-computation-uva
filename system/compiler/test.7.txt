define(BIT_LEN, 64)
define(DIMENSION, 4)

defun mod_mul(x,y,n)
{
//
// ret := x * y (mod n)
// (assuming n has eval(BIT_LEN+2) bits and the most sig. 3 bits are 001)
// (also, both x and y are in [0, n-1])
//
mod_mul_a := 0{2}.x;
mod_mul_b := 0{2}.y;

ret := 0{eval(BIT_LEN+2)};

if mod_mul_b{0} == 1{1} then
                ret := mod_mul_a;
end

tt:=ret - n;
if tt{eval(BIT_LEN+1)} == 0{1} then
   ret := ret - n;
end

for mul_i from 1 to eval(BIT_LEN-1)
begin
    mod_mul_a := mod_mul_a<<1;

    // mod_mul_a %= $4
    tt:=mod_mul_a - n;
    if tt{eval(BIT_LEN+1)} == 0{1} then
            mod_mul_a := mod_mul_a - n;
    end

    if mod_mul_b{mul_i} == 1{1} then
        ret := ret + mod_mul_a;        
    end

    tt:=ret - n;
    if tt{eval(BIT_LEN+1)} == 0{1} then

        ret := ret - n;
    end

end

tt:=ret - n;
if tt{eval(BIT_LEN+1)} == 0{1} then
    ret := ret - n;
end

return ret;
}

defvar x:=input.0{eval(BIT_LEN * DIMENSION)};
defvar a:=input.0{BIT_LEN};
defvar y:=input.1{eval(BIT_LEN * DIMENSION)};
defvar b:=input.1{BIT_LEN};

//n:=10000000810543{eval(BIT_LEN+2)};
n:=10000000002001810643{eval(BIT_LEN+2)};
arrax:=0{eval(BIT_LEN+2)};

// Compute the dot product of x and y modulo n, and add a and b
for i from 0 to eval(BIT_LEN * (DIMENSION-1)) step BIT_LEN
begin
        q:=x{i:eval(BIT_LEN-1)};
        r:=y{i:eval(BIT_LEN-1)};
        zz:=mod_mul(q,r,n);
        nn := zz - n;
        if nn{eval(BIT_LEN+1)} == 0{1} then 
           zz := zz - n; 
        end 
        arrax:=arrax + zz;
end

output.0:=arrax;
output.1:=n;
