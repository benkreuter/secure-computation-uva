// Result from 768 bit test: 27GigaGates
define(BIT_LEN, 16)

define(neg, `
//
// $1 := -$2 (assuming $1 and $2 are of $3 bits)
//
inv := 1{1};

for neg_i from 1 to decr($3)
begin
	inv := inv.1{1};
end
$1 := (inv ^ $2) + 1{$3};
')

define(mod_mul, `
//
// $1 := $2 * $3 (mod $4)
// (assuming $4 has eval(BIT_LEN+2) bits and the most sig. 3 bits are 001)
// (also, both $2 and $3 are in [0, $4-1])
//
mod_mul_a := $2;
mod_mul_b := $3;

$1 := 0{eval(BIT_LEN+2)};

if mod_mul_b{0} == 1{1} then
    $1 := mod_mul_a;
end



for mul_i from 1 to decr(BIT_LEN)
begin
    mod_mul_a := mod_mul_a{0,BIT_LEN}.0{1};

    // mod_mul_a %= $4
    if ! (mod_mul_a < $4) then
            mod_mul_a := mod_mul_a + neg_$4;
    end

    if mod_mul_b{mul_i} == 1{1} then
        $1 := $1 + mod_mul_a;
    end

    if ! ($1 < $4) then
        $1 := $1 + neg_$4;
    end
end
')

define(mod_exp, `
//
// $1 := $2 ^ $3 (mod $4)
// (assuming $4 has eval(BIT_LEN+2) bits and the most sig. 3 bits are 001)
// (also, both $2 and $3 are in [0, $4-1])
//
mod_exp_a := $2;
mod_exp_b := $3;
$1 := 1{eval(BIT_LEN+2)};

if mod_exp_b{0} == 1{1} then
    $1 := mod_exp_a;
end

for mod_exp_i from 1 to decr(BIT_LEN)
begin

    mod_mul(mod_exp_a, mod_exp_a, mod_exp_a, $4);
    mod_mul(new_$1, $1, mod_exp_a, $4);

    if mod_exp_b{mod_exp_i} == 1{1} then
        $1 := new_$1;
    end
end
')


defvar a := input.0{BIT_LEN};
defvar b := input.1{BIT_LEN};
//ZEROES := 0{eval(BIT_LEN+2)};
//ONES := 1{eval(BIT_LEN+2)};


a := 0{2}.a{0,decr(BIT_LEN)};
b := 0{2}.b{0,decr(BIT_LEN)};
c := 0{2}.255{8}.0{eval(BIT_LEN-8)};

neg(neg_c, c, eval(BIT_LEN+2));

mod_exp(out, a, b, c);

output.1 := out;
