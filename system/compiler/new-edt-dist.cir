define(SEQU_SIZE, `3')

define(vec_dup, `
for vec_i from 0 to decr($3)
	$1[vec_i] := $2[vec_i];
begin
end
')

define(min2, `
	$1 := $2;
	if $1 > $3 then
		$1 := $3;
	end
')

define(min3, `
	min2($1, $2, $3)
	min2($1, $1, $4)
')

define(calc_region, `
define(FRONTIER_LENGTH, `eval(2 ** ($1 - 1))')
// Increase the bit size of the previous frontier by 1
for i from 0 to decr($2)
begin
	this_column[i] := 0{1}.this_column[i];
	this_row[i] := 0{1}.this_row[i];
end

// Initialize remaining frontier elements
for i from $2 to decr(FRONTIER_LENGTH)
begin
	this_column[i] := 0{$1};
	this_row[i] := 0{$1};
end

// Expand the frontier
counter_i := $2{$1};
for i from $2 to eval($2 * 2 - 1)
begin
	vec_dup(prev_column, this_column, FRONTIER_LENGTH)
	vec_dup(prev_row, this_row, FRONTIER_LENGTH)

	// Set boundaries for this frontier
	column_left := prev_column[0];
	this_column[0] := column_left + 1{$1};
	column_last_computed := this_column[0];

	row_up := prev_row[0];
	this_row[0] := row_up + 1{$1};
	row_last_computed := this_row[0];
	
	counter_j := 1{$1};
	for j from 1 to decr(FRONTIER_LENGTH)
	begin
		// compute column
		column_diagonal := column_left;
		column_up := column_last_computed;
		column_left := prev_column[j];

		min3(column_min, column_diagonal, column_up, column_left)

		this_column[j] := column_min + 1{$1};
		if a{j} == b{i} then
			this_column[j] := column_diagonal;
		end

		// compute row
		row_diagonal := row_up;
		row_up := prev_row[j];
		row_left := row_last_computed;

		min3(row_min, row_diagonal, row_up, row_left)

		this_row[j] := row_min + 1{$1};
		if a{i} == b{j} then
			this_row[j] := row_diagonal;
		end
		
		corner_min := 0{$1};
		if counter_i == counter_j then
			min3(corner_min, column_diagonal, column_last_computed, row_last_computed)
			this_column[j] := corner_min + 1{$1};
			this_row[j] := corner_min + 1{$1};
			if a{i} == b{j} then
				this_column[j] := column_diagonal;
				this_row[j] := column_diagonal;
			end
		end		

		column_last_computed := this_column[j];
		row_last_computed := this_row[j];
		
		counter_j := counter_j + 1{$1};
	end
	counter_i := counter_i + 1{$1};
end
undefine(`FRONTIER_LENGTH')
')

//
// Edit Distance
//

// Grab input
defvar a := input.1{SEQU_SIZE};
defvar b := input.0{SEQU_SIZE};

a := 0{1}.a;
b := 0{1}.b;

// Compute base case
this_column[0] := 1{2};
this_row[0] := 1{2};

this_column[1] := 1{2};
this_row[1] := 1{2};
if a{1} == b{1} then
	this_column[1] := 0{2};
	this_row[1] := 0{2};
end

// Calculate remaining rows/columns
calc_region(3, 2)

// Output
one_at_a_time := this_row[SEQU_SIZE];
output.0 := one_at_a_time;
